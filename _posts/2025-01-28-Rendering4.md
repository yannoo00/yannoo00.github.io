---
title:  "여러 도형 렌더링하기 1"
layout: post
excerpt: "Direct를 활용해 다양한 도형을 렌더링해보자. "

categories:
  - Direct
tags:
  - [Direct, rendering]

toc: true
toc_sticky: true
 
date: 2025-01-28
last_modified_at: 2025-01-28
---

# 렌더링 도형 확장

버텍스 버퍼를 추가하여 렌더링하는 도형을 확장해보자.  
도형 확장에서 수행할 내용은 다음과 같다.
1. ImGui 를 프로젝트에 통합한다.
2. 기본 도형을 Cube와 Sphere 로 확장한다.
3. ImGui Combo Box UI 통해서 기본 도형을 바꿔가며 렌더링 한다.
4. 상수 버퍼 (Constant Buffer)를 추가해 도형의 위치를 실시간으로 옮길 수 있도록 준비한다.
5. 키보드 화살표 입력을 통해서 도형을 좌우, 위아래로 움직인다.

<br>


<br>

## 1. ImGui 프로젝트에 통합하기


### 1.1 ImGui 소스 다운
일단 https://github.com/ocornut/imgui 에서 소스를 다운받을 수 있다.  
이렇게 다운받은 코드를 자신의 프로젝트에 포함하여 빌드해서 사용하면 된다.

ImGui는 C++용 GUI Library이다. 깃허브에는 소스코드와 다양한 예제도 포함되어있어 테스트해볼 수 있다.

예제를 실행하면

![Image](https://github.com/user-attachments/assets/24b3a311-1afb-41a3-8c48-c06563d5f5c9)
위와 같은 GUI가 구성된다.

프로젝트에 포함시키기 위해 cpp, .h 파일들과 함께 backends 폴더에서 자신이 활용할 백엔드에 맞는 추가적인 헤더들을 받아야 한다.  
필요한 소스코드들을 다운받아 프로젝트에 포함시키고,  
~~~cpp
#include "ImGui/imgui.h"
#include "ImGui/imgui_internal.h"
#include "ImGui/imgui_impl_dx11.h"
#include "imGui/imgui_impl_win32.h"
~~~ 
위처럼 ImGui 관련 헤더를 포함시켜준다.



### 1.2 생성, 소멸
~~~cpp
extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// 각종 메시지를 처리할 함수
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	if (ImGui_ImplWin32_WndProcHandler(hWnd, message, wParam, lParam))
	{
		return true;
	}
	
	switch (message)
	{
	case WM_DESTROY:
		// Signal that the app should quit
		PostQuitMessage(0);  
		break;
	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}

	return 0;
}
~~~
ImGui용 WndProcHandler를 선언하고 WndProc함수에서 호출해준다.

~~~cpp
	// 여기에서 ImGui를 생성합니다.
	IMGUI_CHECKVERSION();
	ImGui::CreateContext();
	ImGuiIO& io = ImGui::GetIO();
	ImGui_ImplWin32_Init((void*)hWnd);
	ImGui_ImplDX11_Init(renderer.Device, renderer.DeviceContext);

	// 여기에서 ImGui 소멸
	ImGui_ImplDX11_Shutdown();
	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();
~~~
렌더러 생성 직후에 초기화 함수를 호출하고, main loop 이후에 바로 소멸 함수를 호출한다.



### 1.3 ImGui 컨트롤 생성 및 렌더링 요청


~~~cpp
		// 생략 ...
		
		ImGui_ImplDX11_NewFrame();
		ImGui_ImplWin32_NewFrame();
		ImGui::NewFrame();

		// 이후 ImGui UI 컨트롤 추가는 ImGui::NewFrame()과 ImGui::Render() 사이인 여기에 위치합니다.
    ImGui::Begin("Jungle Property Window");
		ImGui::End();

		ImGui::Render();
		ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

		renderer.SwapBuffer();
	}
~~~
스왑버퍼를 호출하기 직전에 ImGui 렌더링 준비, 컨트롤 설정, 렌더링 요청 함수를 넣는다.  
Begin과 End함수로 창을 생성할 수 있다.  
이 사이에 Button, Text 등 다양한 요소를 윈도우에 추가할 수 있다.



<br>

## 2. 기본 도형 확장

## 2.1 큐브 렌더링 


~~~cpp
FVertexSimple cube_vertices[] =
{
	// Front face (Z+)
	{ -0.5f, -0.5f,  0.5f,  1.0f, 0.0f, 0.0f, 1.0f }, // Bottom-left (red)
	{ -0.5f,  0.5f,  0.5f,  1.0f, 1.0f, 0.0f, 1.0f }, // Top-left (yellow)
	{  0.5f, -0.5f,  0.5f,  0.0f, 1.0f, 0.0f, 1.0f }, // Bottom-right (green)
	{ -0.5f,  0.5f,  0.5f,  1.0f, 1.0f, 0.0f, 1.0f }, // Top-left (yellow)
	{  0.5f,  0.5f,  0.5f,  0.0f, 0.0f, 1.0f, 1.0f }, // Top-right (blue)
	{  0.5f, -0.5f,  0.5f,  0.0f, 1.0f, 0.0f, 1.0f }, // Bottom-right (green)

	// Back face (Z-)
	{ -0.5f, -0.5f, -0.5f,  0.0f, 1.0f, 1.0f, 1.0f }, // Bottom-left (cyan)
	{  0.5f, -0.5f, -0.5f,  1.0f, 0.0f, 1.0f, 1.0f }, // Bottom-right (magenta)
	{ -0.5f,  0.5f, -0.5f,  0.0f, 0.0f, 1.0f, 1.0f }, // Top-left (blue)
	{ -0.5f,  0.5f, -0.5f,  0.0f, 0.0f, 1.0f, 1.0f }, // Top-left (blue)
	{  0.5f, -0.5f, -0.5f,  1.0f, 0.0f, 1.0f, 1.0f }, // Bottom-right (magenta)
	{  0.5f,  0.5f, -0.5f,  1.0f, 1.0f, 0.0f, 1.0f }, // Top-right (yellow)

	// Left face (X-)
	{ -0.5f, -0.5f, -0.5f,  1.0f, 0.0f, 1.0f, 1.0f }, // Bottom-left (purple)
	{ -0.5f,  0.5f, -0.5f,  0.0f, 0.0f, 1.0f, 1.0f }, // Top-left (blue)
	{ -0.5f, -0.5f,  0.5f,  0.0f, 1.0f, 0.0f, 1.0f }, // Bottom-right (green)
	{ -0.5f,  0.5f, -0.5f,  0.0f, 0.0f, 1.0f, 1.0f }, // Top-left (blue)
	{ -0.5f,  0.5f,  0.5f,  1.0f, 1.0f, 0.0f, 1.0f }, // Top-right (yellow)
	{ -0.5f, -0.5f,  0.5f,  0.0f, 1.0f, 0.0f, 1.0f }, // Bottom-right (green)

	// Right face (X+)
	{  0.5f, -0.5f, -0.5f,  1.0f, 0.5f, 0.0f, 1.0f }, // Bottom-left (orange)
	{  0.5f, -0.5f,  0.5f,  0.5f, 0.5f, 0.5f, 1.0f }, // Bottom-right (gray)
	{  0.5f,  0.5f, -0.5f,  0.5f, 0.0f, 0.5f, 1.0f }, // Top-left (purple)
	{  0.5f,  0.5f, -0.5f,  0.5f, 0.0f, 0.5f, 1.0f }, // Top-left (purple)
	{  0.5f, -0.5f,  0.5f,  0.5f, 0.5f, 0.5f, 1.0f }, // Bottom-right (gray)
	{  0.5f,  0.5f,  0.5f,  0.0f, 0.0f, 0.5f, 1.0f }, // Top-right (dark blue)

	// Top face (Y+)
	{ -0.5f,  0.5f, -0.5f,  0.0f, 1.0f, 0.5f, 1.0f }, // Bottom-left (light green)
	{ -0.5f,  0.5f,  0.5f,  0.0f, 0.5f, 1.0f, 1.0f }, // Top-left (cyan)
	{  0.5f,  0.5f, -0.5f,  0.5f, 1.0f, 1.0f, 1.0f }, // Bottom-right (white)
	{ -0.5f,  0.5f,  0.5f,  0.0f, 0.5f, 1.0f, 1.0f }, // Top-left (cyan)
	{  0.5f,  0.5f,  0.5f,  0.5f, 0.5f, 0.0f, 1.0f }, // Top-right (brown)
	{  0.5f,  0.5f, -0.5f,  0.5f, 1.0f, 1.0f, 1.0f }, // Bottom-right (white)

	// Bottom face (Y-)
	{ -0.5f, -0.5f, -0.5f,  0.5f, 0.5f, 0.0f, 1.0f }, // Bottom-left (brown)
	{ -0.5f, -0.5f,  0.5f,  1.0f, 0.0f, 0.0f, 1.0f }, // Top-left (red)
	{  0.5f, -0.5f, -0.5f,  1.0f, 0.0f, 0.5f, 1.0f }, // Bottom-right (purple)
	{ -0.5f, -0.5f,  0.5f,  1.0f, 0.0f, 0.0f, 1.0f }, // Top-left (red)
	{  0.5f, -0.5f,  0.5f,  0.0f, 1.0f, 0.0f, 1.0f }, // Top-right (green)
	{  0.5f, -0.5f, -0.5f,  1.0f, 0.0f, 0.5f, 1.0f }, // Bottom-right (purple)
};


/*
  기존 삼각형 버텍스
	FVertexSimple* vertices = triangle_vertices;
	UINT ByteWidth = sizeof(triangle_vertices);
	UINT numVertices = sizeof(triangle_vertices) / sizeof(FVertexSimple);
*/
	FVertexSimple* vertices = cube_vertices;
	UINT ByteWidth = sizeof(cube_vertices);
	UINT numVertices = sizeof(cube_vertices) / sizeof(FVertexSimple);
  ~~~
큐브 vertex 배열을 추가하고 추가한 큐브 vertex에 따라 버텍스버퍼를 생성하도록 수정한다.  
이 큐브는 6개의 면을 가지고(육면체), 각 면은 두 개의 삼각형으로 이뤄져있다.  
삼각형은 다시 3개의 정점을 가지고, 각 정점은 7개의 float 값을 가지는 것이다.  
정점은 {x, y, z, r, g, b, a} 로 표현된다(xyz는 3D공간에서의 위치).  



<br>

## 2.2 구 렌더링 
앞서 육면체의 경우 한 면에 삼각형 2개, 총 2*6 12개의 삼각형으로 렌더링 하는 것을 보았다.  
그럼 구는 어떻게 렌더링 해야할까? 아주 작은 단위의 삼각형으로 쪼개어 표현해야 할 것이다.  
구면 좌표계를 이용해서 구면 좌표를 계산해두고 그 결과 생성된 아주 많은 정점을 미리 저장해두고 사용한다.  
이 예제에서는 정점 데이터가 저장된 헤더파일을 사용했다.




<br>
<br>

## 3. ImGui 활용하여 이벤트로 렌더링 도형 바꾸기



