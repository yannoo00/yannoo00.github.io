---
layout: post
title: "SW Expert Academy 단순 2진 암호코드"
categories: PS
tags: 구현
---

## 문제 정보
- 문제 링크: [SW Expert Academy 단순 2진 암호코드](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15FZuqAL4CFAYD)
- 난이도: <span style="color:#000000">D3</span>
- 완료일: 2025년 3월 4일
- 유형: 구현
- 특이사항: 삼성전자 교육 문제

문제를 간략히 설명해보겠다.  
2차원 배열로 된 암호를 입력 받는다. 예시는 아래와 같다.  

16 80

00000000000000000000000000000000000000000000000000000000000000000000000000000000

00000000000000000000000000000000000000000000000000000000000000000000000000000000

00000000000000000000000000000000000000000000000000000000000000000000000000000000

00000000000000000000000000000000000000000000000000000000000000000000000000000000

00000000000000000000000000000000000000000000000000000000000000000000000000000000

00000000000000000000000000000000000000000000000000000000000000000000000000000000

00000000000000011101101100010111011011000101100010001101001001101110110000000000

00000000000000011101101100010111011011000101100010001101001001101110110000000000

00000000000000011101101100010111011011000101100010001101001001101110110000000000

00000000000000011101101100010111011011000101100010001101001001101110110000000000

00000000000000011101101100010111011011000101100010001101001001101110110000000000

00000000000000011101101100010111011011000101100010001101001001101110110000000000

00000000000000011101101100010111011011000101100010001101001001101110110000000000

00000000000000000000000000000000000000000000000000000000000000000000000000000000

00000000000000000000000000000000000000000000000000000000000000000000000000000000

00000000000000000000000000000000000000000000000000000000000000000000000000000000

여기서, 암호는 0~9의 숫자를 정해진 방식의 7bit로 표현하는 것이다. 단 모든 값은 2^0 자리에 1이 들어있다. → 이걸로 암호의 마지막 자리가 1이라는 것을 알 수 있으며 문제 조건에서 숫자는 총 8개라고 했으므로  
마지막 1이 나타난 자리 + 55가 암호의 시작 위치가 된다.  

주어진 배열 중에서 0만으로 구성된 행은 암호가 아니므로 pass하고, 1이 섞인 값에서 암호의 시작 위치를 찾아 해당 위치부터 7자리씩 문자를 읽어 복호화 하면 된다.

문제 이해가 어렵고 조건도 전체적으로 난해하다.   
개떡같이 말해도 찰떡같이 알아들을 수 있는지를 확인하는 문제 느낌…  
특히 암호는 한 줄 뿐이고 같은 암호가 여러 줄에 걸쳐 출력되는데 그것에 관한 아무런 언급이 없다는게 참…….  

{% highlight C++ %} {% raw %}
```C++
#include <iostream>
#include <stdio.h> // = cstdio
#include <cmath>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

string s;

int arr[50][100];

int main()
{
	int test_case;
	int T;
	
	cin >> T;
	
	for (test_case = 1; test_case <= T; ++test_case)
	{
		int n, m;
		int ans = 0;
		cin >> n >> m;
		
		for (int i = 0; i < n; ++i)
		{
			cin >> s;

			bool isKey = false;
			int lastIdx = 0;
			for (int j = 0; j < m; j++)
			{
				if (s[j] == '1')
				{
					isKey = true;
					lastIdx = j;
				}
			}
			if (!isKey) continue; //암호가 아님

			//암호는 반복되어 여러번 등장하고, 각 숫자에 대응하는 암호는 2^6 자리=0, 2^0 자리=1
			//암호를 만났을 때 -> (lastIdx-55)~(lastIdx)가 암호
			//2^8 = 256
			else
			{
				int even = 0;
				int odd = 0;
				for (int i = 0; i < 56; (i += 7))
				{
					int cmp = 0;
					int target = 0;
					for (int j = 0; j < 7; j++)
					{
						target += (s[(lastIdx-55) + i + j]-'0') << (6 - j);
					}
					cmp = (cmp | target);
					//cout << cmp << endl;

					if (cmp == 13) //0
					{
						if ((i / 7 + 1) & 1) //홀수
						{
							odd += 0;
						}
						else
						{
							even += 0;
						}
					}
					else if (cmp == 25) //1
					{
						if ((i / 7 + 1) & 1) //홀수
						{
							odd += 1;
						}
						else
						{
							even += 1;
						}
					}
					else if (cmp == 19) //2
					{
						if ((i / 7 + 1) & 1) //홀수
						{
							odd += 2;
						}
						else
						{
							even += 2;
						}
					}
					else if (cmp == 61) //3
					{
						if ((i / 7 + 1) & 1) //홀수
						{
							odd += 3;
						}
						else
						{
							even += 3;
						}
					}
					else if (cmp == 35) //4 
					{
						if ((i / 7 + 1) & 1) //홀수
						{
							odd += 4;
						}
						else
						{
							even += 4;
						}
					}
					else if (cmp == 49) //5
					{
						if ((i / 7 + 1) & 1) //홀수
						{
							odd += 5;
						}
						else
						{
							even += 5;
						}
					}
					else if (cmp == 47) //6
					{
						if ((i / 7 + 1) & 1) //홀수
						{
							odd += 6;
						}
						else
						{
							even += 6;
						}
					}
					else if (cmp == 59) //7 
					{
						if ((i / 7 + 1) & 1) //홀수
						{
							odd += 7;
						}
						else
						{
							even += 7;
						}
					}
					else if (cmp == 55) //8
					{
						if ((i / 7 + 1) & 1) //홀수
						{
							odd += 8;
						}
						else
						{
							even += 8;
						}
					}
					else if (cmp == 11) //9
					{
						if ((i / 7 + 1) & 1) //홀수
						{
							odd += 9;
						}
						else
						{
							even += 9;
						}
					}
				}//암호 검사 for문 끝
				//cout << "odd" << odd << " " << "even" << even << endl;

				if ((odd * 3 + even) % 10 == 0)
				{
					ans = odd + even;
				}
				else
					ans = 0;
			}//else문			
		}//전체 문자열 검사 for문
		

		cout << "#" << test_case << " "<< ans <<"\n";
	}
}
```
{% endraw %}{% endhighlight %}

일단 무작정 구현은 했는데 분명 이것보다 더 예쁘게 만들 수 있을 것 같다.

시간 제한이 10초로 아주 널널하고, 문제 내용을 봤을 때 정확한 구현에 초점이 맞춰진 것 같다.
