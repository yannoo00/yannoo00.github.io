---
title:  "공유데이터 동기화 - Lock"
layout: post
excerpt: "Lock"

categories:
  - Network
tags:
  - [Network]

toc: true
toc_sticky: true
 
date: 2025-04-29
last_modified_at: 2025-04-29
---

<br>

## 공유 데이터의 동기화 문제 - Lock 기초

```cpp

//
#include "pch.h"
#include <iostream>
#include "CorePch.h"

#include <thread>
#include <atomic> //atomic: All or nothing
#include <mutex>

using namespace std;

vector<int32> v; //container 자료구조라고 하자.
mutex m; //자물쇠(occupied)

// RAII pattern(Resource Acquisition is initialization)
template<typename T>
class LockGuard
{
public:
    LockGuard(T& m)
    {
        _mutex = &m;
        _mutex->lock();
    }

    ~LockGuard()
    {
        _mutex->unlock();
    }
};

void Push()
{
    for (int32 i = 0; i < 10'000; ++i)
    {
        LockGuard<mutex> lockGuard(m);

        m.lock();
        
        v.push_back(i);

        m.unlock();
        
    }
}


int main()
{
    
    thread t1(Push);
    thread t2(Push);
    
    t1.join();
    t2.join();
    
    cout << v.size() << endl;
}


```

공유 데이터일 때에도 원자적 계산을 보장하는 Atomic 선언은 편리하지만  
자료형 개념이기 때문에 atomic형으로 vector를 만들어서 push 연산을 활용하거나 할 수는 없다.  

공유 데이터 접근을 제한하는 또 다른 방법으로,  
하나의 변수가 아니라 공유 데이터에 대한 접근을 제한할 수 있는 mutex가 존재한다.  

위처럼 mutex->lock()을 사용하면 unlock이 될 때까지 공유 데이터에 접근할 수 없다.   
따라서 vector에 10,000개의 push가 온전히 이뤄짐을 보장한다.  

이를 보면 무척 편리하지만 unlock을 실수로 안해줬을 때 사고가 발생할 수 있음을 알 수 있다...  
동적할당을 해제하지 않아 발생하는 memory leak과 비슷한 방식으로  
lock을 걸었다면 반드시 unlock을 해줘야 하고, 중간에 들어오는 탈출문이나 기타 여러 함수 호출 등으로 인해 unlock을 건너뛰게 될 수도 있다.  

이런 상황을 방지하기 위해 LockGuard class를 만든 것처럼 (lock_guard가 library로 존재함) 소멸 시에 lock 해제를 보장하는 방식 등으로 unlock을 보장하게 만들어 사용해야 한다.  

<br>
<br>
<br>

참고: _인프런 Rookiss_