---
title:  "new() delete()"
layout: post
excerpt: "new() delete()"

categories:
  - C++
tags:
  - [C++]

toc: true
toc_sticky: true
 
date: 2025-06-06
last_modified_at: 2025-06-06
---

<br>

## new()
[ new()및 delete()연산자](https://learn.microsoft.com/ko-kr/cpp/cpp/new-and-delete-operators?view=msvc-170)

new는 C++에서 동적으로 객체를 할당하는 연산자다.  
new()는 두 가지 동작을 수행한다.  

```cpp
T* ptr = static_cast<T*>(operator new(sizeof(T)));  // 1. 메모리 할당
new(ptr) T(args);                                   // 2. 생성자 호출 (placement new)
```
1번 메모리 할당 과정을 살펴보면 일단 new 연산자에 생성 요청을 받은 클래스 T를 넣는다.  
operator new 내부에서는  
```cpp
void* operator new(std::size_t size) {  // size = 16
    if (size == 0) size = 1;
    
    while (true) {
        void* ptr = std::malloc(16);  // 힙에서 16바이트 할당
        if (ptr) {
            return ptr;  // 성공시 주소 반환 (예: 0x1234ABC0)
        }
        
        // 실패시 new_handler 처리 또는 bad_alloc 예외
        std::new_handler handler = std::get_new_handler();
        if (handler) handler();
        else throw std::bad_alloc();
    }
}
```
이렇게 받은 class의 size만큼 malloc으로 heap 공간을 할당 받는다.  
이 때 공간이 충분했다면 return으로 해당 할당 받은 주소를 기리키는 주소(void*)를 반환한다.  
그 다음 static_cast<T*>를 통해 이 주소를 class pointer로 변환한다.  

공간이 부족하다면 new handler를 호출해서 다시 시도하고, handler가 없다면 exception을 뱉는다.  

이후 new(ptr) T(args);는 placement new라는 문법인데,  
추가 메모리 할당 없이 이미 할당된 공간에서 class의 생성자를 호출한다.

<br>

이렇게 new의 기본 동작을 모두 구현하되, 필요한 기능을 추가로 넣을 수 있는 class를 만들어보자.  


```cpp
#include "pch.h"
#include "Allocator.h"

/*-------------------
	BaseAllocator
-------------------*/

void* BaseAllocator::Alloc(int32 size)
{
	return ::malloc(size);
}

void BaseAllocator::Release(void* ptr)
{
	::free(ptr);
}


/*  Memory.h  */
#pragma once
#include "Allocator.h"

template<typename Type, typename... Args>
Type* xnew(Args&&... args)
{
	Type* memory = static_cast<Type*>(BaseAllocator::Alloc(sizeof(Type)));

	new(memory)Type(forward<Args>(args)...); // placement new

	return memory;
}

template<typename Type>
void xdelete(Type* obj)
{
	obj -> ~Type();
	BaseAllocator::Release(obj);
}
```
<br>

현재 allocator에는 기본 malloc, free 구현만 있는 상태다. 여기에 원하는 기능을 추가해서 사용하면 된다.  
placement new의 forward\<Args>는 lvalue, rvalue를 유지하며 전달해서 불필요한 복사, 이동 연산을 방지할 수 있다.  


<br>
<br>
<br>
<br>
참고: _인프런 Rookiss_