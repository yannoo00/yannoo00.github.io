---
title:  "Allocator"
layout: post
excerpt: "Allocator"

categories:
  - AI
tags:
  - [AI, CLOVA]

toc: true
toc_sticky: true
 
date: 2025-07-25
last_modified_at: 2025-07-25
---

<br>

## CLOVA AI Agent

네이버 클로바 AI를 이용하여 금융 도메인 AI Agent를 만들어보자.  
이 agent는 "삼성전자 어제 종가 알려줘" 라는 쿼리에 금융 데이터를 활용하여 올바른 데이터를 제공한다.  
 
주식 데이터는 yfinance 라이브러리를 활용해서 얻어왔다.  
이 때 주식 정보를 기업명이 아닌 기업명마다 할당되어 있는 Ticker 값으로 가져와야 한다.    
  "삼성전자": "005930.KS",   "삼성카드": "029780.KS",  이런 식이다.  

문제는 쿼리에 부정확한 기업명도 들어올 수 있다는 것이다. 예를 들어 "삼전", "엘지 엔솔" 등 보편적으로 쓰이는 약어도 많다.  
정확한 주식 데이터를 가져오기 위해선 사용자가 의도한 정확한 기업명으로 Ticker 값을 찾아야 한다.  

<img width="1699" height="902" alt="Image" src="https://github.com/user-attachments/assets/23d6700b-a460-49d1-9505-18ae569ea7c2" /> 
이를 해결하기 위해서 CLOVA의 [Function Calling](https://api.ncloud-docs.com/docs/clovastudio-chatcompletionsv3-fc)과 텍스트 임베딩을 활용했다.  

대략적인 Flow Chart는 다음과 같다.  
<center><img width="497" height="928" alt="Image" src="https://github.com/user-attachments/assets/c7fa1fd3-56b2-43be-a09c-2d1084faaaae" /></center>


### Function Calling

Function Calling은 사전에 정의해둔 함수들을 clova에게 전달하면 auto로(조정 가능) 어떤 function을 어떤 arguments로 call해야할지 CLOVA가 선택해주는 기능이다.  

즉 챗봇에게 질의하면 대화 형식의 텍스트 답변 대신 실행할 함수와 파라미터를 반환해주는 것이다.  
request 형식을 보자.  

<center><img width="600" height="450" alt="Image" src="https://github.com/user-attachments/assets/f410094f-e449-47b7-9e21-bee9a3891b4b" />   

request body의 function calling 관련 내용</center>

<center><img width="600" height="450" alt="Image" src="https://github.com/user-attachments/assets/eec095bd-9525-4e7e-ae25-24b61ef858d1" />  

tools</center>  

function calling으로 호출 필요 여부를 판단하게 하고 싶은 함수들을 tools 양식을 맞춰 전달하면 된다.  
일단 query 자체에 기업명이 포함되어 있는지에 따라 두 함수중 하나를 호출하게 했다.  
두 함수에 대한 명세를  
```python
       """CLOVA Function Calling용 함수 정의"""
       [
           {
               "type": "function",
               "function": {
                   "name": "convert_query_to_ticker",
                   "description": "사용자 쿼리에서 기업명을 찾아 정확한 ticker 코드로 치환한 새로운 쿼리를 반환합니다. 주식 관련 질문에서 기업명이 포함된 경우 반드시 호출해야 합니다.",
                   "parameters": {
                       "type": "object",
                       "properties": {
                           "user_query": {
                               "type": "string",
                               "description": "사용자의 원본 질문 전체"
                           },
                           "extracted_company_name": {
                               "type": "string",
                               "description": "사용자 쿼리에서 추출한 기업명 또는 기업 관련 키워드 (예: '삼전', '엘지에너솔', '현차', '카카오' 등). 사용자가 실제로 언급한 표현 그대로 추출해주세요."
                           }
                       },
                       "required": ["user_query", "extracted_company_name"]
                   }
               }
           },

           {
               "type": "function",
               "function": {
                   "name": "nothing_to_convert",
                   "description": "사용자 쿼리에 기업명이 포함되지 않은 경우 호출합니다.",
                   "parameters": {
                       "type": "object",
                       "properties": {
                           "user_query": {
                               "type": "string",
                               "description": "사용자의 원본 질문 전체"
                           },
                       },
                      "required": ["user_query"]
                    }
               }
           },
       ]
```
이렇게 작성해서 request body에 보낸다.  
이 설명을 바탕으로 어떤 funciton을 어떤 params로 호출할지 return해준다.  

```python

   def nothing_to_convert(self, user_query):

      return {
           "original_query": user_query,
           "converted_query": user_query,
       }


   def convert_query_to_ticker(self, user_query, extracted_company_name):
       """
       LLM이 추출한 기업명을 ticker로 치환한 새 쿼리 반환
       1. 바로 name2ticker에 key 존재하는지 확인. 존재하면 임베딩 없이 바로 return
       2. 줄임말, 약어 등으로 입력되어서 name2ticker에서 바로 매핑 불가한 경우 -> 자체적으로 LLM 호출 +1회(임베딩, 선택)
       """

       # 0. 바로 매핑 시도
       if extracted_company_name in self.name_to_ticker:
           print("유사도 검색 없이 변환 성공")
           ticker = self.name_to_ticker[extracted_company_name]
           converted_query = self._replace_company_with_ticker(user_query, extracted_company_name, ticker)

           return {
              "original_query": user_query,
              "converted_query": converted_query,
           }

       # 1. 적절한 기업명으로 변환 필요한 상황. 추출된 기업명으로 임베딩 유사도 검색
       candidates = self.search_similar_companies(extracted_company_name)

       # 2. 상위 후보들 중에서 LLM으로 최종 선택
       candidate_names = [c['company'] for c in candidates[:20]]
       print(candidate_names)

       selection_prompt = f"""
       사용자가 언급한 기업명: "{extracted_company_name}"
       원본 쿼리: "{user_query}"

       유사한 정식 기업명 후보들:
       {', '.join(candidate_names)}

       유사한 정식 기업명 후보들을 검토하고, 사용자의 의도를 파악해서 정확한 기업명만을 content로 반환할 것.
       """

       # 3. LLM으로 정식 기업명 선택
       selected_company = self._call_llm_for_selection(selection_prompt)

       if not selected_company or selected_company not in self.name_to_ticker:
           print(f"LLM이 정확하지 않은 이름 <{selected_company}>으로 변환함. 그냥 유사도 1등 선택")
           selected_company = candidate_names[0]
          #  return {

          #      # 에러 출력 대신 유사도 1위 기업명으로 변환해주기
          #      # 혹은 전혀 존재하지 않는 기업명일수도? -> "기업명을 정확히 입력해주세요"와 같은 메시지 출력하는 것도 방법

          #      "error": f"선택된 기업 '{selected_company}'의 ticker를 찾을 수 없습니다.",
          #      "original_query": user_query,
          #      "extracted_company_name": extracted_company_name,
          #      "selected_company": selected_company,
          #      "converted_query": user_query
          #  }

       # 4. 기업명 → ticker 변환
       ticker = self.name_to_ticker[selected_company]

       # 5. 쿼리에서 추출된 기업명을 ticker로 치환
       converted_query = self._replace_company_with_ticker(user_query, extracted_company_name, ticker)

       return {
           "original_query": user_query,
           "extracted_company_name": extracted_company_name,
           "identified_company": selected_company,
           "converted_query": converted_query,
       }

```
실제 함수는 위와 같다.  
만약 사용자의 쿼리에 기업명이 없다면 nothing_to_convert를 호출하고 이는 딱히 아무런 동작도 없이 쿼리를 그대로 반환해준다.  
사용자의 쿼리에 기업명이 있다면 그 기업명에 해당하는 text를 param으로 추가하여 convert_query... 함수를 호출해준다.  
(reponse로 주어지는 함수명과 param을 바탕으로 실행은 직접 해야한다)  

그러면 {"기업명" : ticker값} 으로 매핑되어있는 dictionary에서 기업명에 해당하는 text가 key로 존재하는지 검사하고  
key가 있다면 -> 기업명이 "삼성전자"와 같이 완전하게 쿼리로 들어온 것이므로 그대로 기업명을 ticker값으로 바꾸어 반환한다.  
key가 없다면 -> "삼전"과 같이 불완전한 기업명이 쿼리로 들어온 것이므로 이것을 완전하게 변환하는 과정을 거쳐 반환한다.  

"삼전"을 "삼성전자"로 만들기 위해서 다시 LLM을 사용해야 한다.  

### Embedding  
