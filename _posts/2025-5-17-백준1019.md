---
layout: post
title: "백준 1019 책 페이지"
categories: PS
tags: 구현
---

## 문제 정보
- 문제 링크: [백준 1019 책 페이지](https://www.acmicpc.net/problem/1019)
- 난이도: 플레티넘5
- 완료일: 2025년 5월 17일
- 유형: 수학 구현

### 내 코드

{% highlight C++ %} {% raw %}
```C++
#include <iostream>
#include <string>
#include <cmath>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;
typedef long long ll;

ll n;
ll shown[10];

string s;


int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);   

//    cin >> s;
    cin >> n;

    if(n <10)
    {
        for(int i=1; i<=n; ++i) shown[i]++;
        for(int i=0; i<=9; ++i) cout << shown[i] <<" ";
        return 0;
    }

    string s = to_string(n);
    ll len = s.length();
    

    ll k = 10;
    ll cnt = 2;
    while(k <= n*10)
    {
        ll quotient = n/k;

        for(ll i=0; i<=9; ++i)
        {
            shown[i] += (k/10) * (quotient);
        }
        ll last = n % k;
        ll boundary = last / (k/10);

        for(int i=0; i<boundary; ++i)
        {
            shown[i] += (k/10);
        }
        shown[boundary] += (last-boundary*(k/10))+1;

        k*=10;
        cnt++;
    }

    ll offset= 0;
    ll test = 1;
    for(int i=1; i<=len; ++i)
    {
        offset += test;
        test*=10;
    }
    shown[0] -= offset;

    for(auto &iter : shown)
    {
        cout << iter << " ";
    }

    return 0;
}
```
{% endraw %}{% endhighlight %}  

뭔가… 규칙을 귀납적으로 찾아서 풀었다. 

0의 개수에 대한 처리가 헷갈려서 계속 틀리고 있었는데, 
이리저리 코드를 바꿔보던 중 n이 1의 자리면 구한 0의 개수에서 -1, 10의 자리면 -11, 100의 자리면 -111, … 라는 규칙을 찾아서 해결할 수 있었다. 당연하게도 페이지가 1의 자리일 때, 10의 자리일 때, 100의 자리일 때, … 마다 0이 맨 앞에 오는 경우를 제외해주면 되는건데, 복잡하게 생각하다가 점점 산으로 갔던 것 같다.

일단 기본 아이디어는 
각 자릿수에 0~9까지의 숫자가 등장할 수 있는 경우를 카운트하는 것이다.

예를 들어 1의 자리에 0~9가 오기 위해선 N을 10으로 나눈 몫을 이용할 수 있다.
N=23이라고 하자. 10으로 나눈 **몫은 2**이다. 
이 말은 0~9, 10~19 이렇게 **두 세트**로 0~9의 등장이 보장되는 것을 의미한다(0이 각 자리 맨 앞에 오는 경우는 나중에 한 번에 제외하면 된다)

즉 10의 제곱수 k로 나눈 몫은 k/10의 자리에 0~9가 등장할 수 있는 횟수를 의미한다. 
그럼 이 몫이 보장해주지 못하는 값에 대해서는 어떻게 생각할 수 있을까?

N = 2258인 경우를 생각해보자
1000으로 나눠 몫=2를 얻었고, 100의 자리에 000~099(이 경우 역시 나중에 한 번에 제외할 대상인 것이다), 100~199, 200~299, … , 900~999로 0부터 9가 오는 경우가 1000의 자리가 0일 때 한 번, 
1일 때 1000~1099, 1100~1199, … , 1900~1999 이렇게 1000의 자리가 1일 때 한 번으로 총 두 번 보장되게 된다.
100의 자리에 0부터 9까지가 오게 되면, 100번동안 그 백의 자리 수가 반복될 수 있다. (1900~1999)
하지만 N=2258이어서 1000의 자리가 2가 되면 0부터 9까지 100번씩 백의 자리를 지킨다고 보장할 수 없다.
이 경우에는 백의 자리가 0, 1일 때까지만 보장 가능하다. 
2는 2200~2258까지 총 59번까지만 자리를 지킬 수 있는 것이다. 

이 같은 나머지에 대한 처리를 코드에서 boundary를 구해 매 자리 계산마다 수행하고 있다. 
추가 예시로 N = 2258 케이스에서 100으로 나눠 10의 자리에 0~9가 위치하는 경우를 계산할 때에도 
백의 자리까지 숫자가 258 이므로 00~99, 100~199 두 세트로 십의 자리에 0~9까지 숫자가 올 수 있는 경우가 보장되지만 
백의 자리 200부터는 200~258까지만 보장하므로 0부터 4까지는 백의 자리가 2일 때에도 10번씩 십의 자리를 지킬 수 있지만 5는 250~258까지 9번만 지킬 수 있다(6부터는 아예 올 수 없다).

헷갈리지 말아야 할 것은 이 때 100으로 나눈 나머지에 대해 추가 계산을 하는 것으로, 
2200까지 십의 자리에 0부터 9가 오는 것은 모두 계산했다는 것이다. 
십의 자리에 오는 것과 백의 자리에 오는 것처럼 다른 자리에 오는 경우는 전혀 별개로 카운트 해주어야 한다. 한 페이지 번호 안에 몇 개가 있는지를 세는 것이기 때문이다. 

0도 똑같이 계산해버리고 맨 앞에 0이 오는 경우를 모두 빼주게 되면 
1의 자리일 때 0이 맨앞에 오는 경우 1개,
10의 자리일 때 10개, (00~09)
100의 자리일 때 100개,(000~099) … 이렇게 11111… 꼴로 n의 자리수에 맞춰 빼주면 된다.