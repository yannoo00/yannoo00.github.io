---
title:  "Secure Shell(SSH)을 활용한 SCP"
layout: post
excerpt: "SSH"

categories:
  - others 
tags:
  - [SSH, SCP]

toc: true
toc_sticky: true
 
date: 2026-01-05
last_modified_at: 2026-01-05
---

<br>

## SSH  

Secure Shell(SSH)이란 컴퓨터 간의 통신을 위한 보안 네트워크 프로토콜이다.  

<img width="931" height="472" alt="Image" src="https://github.com/user-attachments/assets/e1a5487f-215a-4885-a025-eabb4df4982e" />  

깃허브에 SSH로 접속하고, AWS EC2 인스턴스에 SSH로 들어가고, 회사 서버를 SSH로 관리한다. 개발자라면 하루에도 몇 번씩 SSH를 사용할 수도 있다.    

### Telnet

SSH의 필요를 이해하기 위해, 1970년대 탄생한 원격 터미널 접속 프로토콜 Telnet에 대해 알아보자. 
70년대 쯤이면 물리적으로 멀리 떨어진 컴퓨터에 접속해서 명령어를 실행할 수 있다는 것만으로 혁신적인 일이었을 것이다.  

하지만 Telnet에는 치명적인 결함이 있었다. **모든 데이터를 평문으로 전송한다는 것**이다. 사용자 이름, 비밀번호, 실행하는 명령어, 전달하는 파일 내용까지 전부 암호화 없이 그대로 네트워크를 탄다.  

Wireshark 같은 패킷 캡처 도구를 켜고 누군가의 Telnet 세션을 엿보면 타이핑하는 내용이 실시간으로 보이고, 로그인할 때 입력한 비밀번호도 `password: admin1234` 이런 식으로 평문 그대로 보인다.  

1990년대까지만 해도 인터넷이 보편화되지 않았고, 네트워크는 주로 대학이나 연구소 같은 폐쇄적인 환경에서 사용되었을테니 Telnet의 보안 취약점이 그리 큰 문제가 아니었다. 하지만 인터넷이 폭발적으로 성장하면서 상황이 달라졌다.  



### 왜 패킷은 쉽게 캡처될까?

"내가 서버 IP와 포트 번호를 정확히 지정해서 보내는데, 중간에 누가 어떻게 가로챈다는 거지?"라고 생각할 수 있다. 전송하는 데이터가 그 상대방의 포트까지 어떻게 전달될지를 생각해보자.  

내가 AWS 서버에 접속한다고 생각해보자. 패킷이 다음과 같이 전달될 수 있다:

1. 노트북
2. 집 공유기
3. 건물의 라우터
4. ISP(KT, SKT 등)의 여러 라우터
5. 국제 해저 케이블
6. 미국/유럽의 여러 라우터
7. AWS 데이터센터의 라우터
8. 최종 서버

traceroute 명령어로 확인해보면 패킷이 10~20개 이상의 중간 지점(홉)을 거치는 걸 볼 수 있다. 이 과정에서 각 라우터는 패킷을 어디로 보낼지 결정하기 위해 패킷 헤더를 읽어야 하고, **이론적으로는 패킷 내용도 볼 수 있다**.

더 위험한 건 같은 로컬 네트워크를 공유하는 경우다. 카페에서 공용 와이파이를 쓰거나, 회사에서 같은 네트워크에 연결되어 있다면, 누군가가 네트워크 카드를 promiscuous mode로 설정하고 ARP spoofing 같은 기법을 사용하면 모든 패킷을 가로챌 수 있다.

2000년대 초반, 공항이나 카페의 공용 와이파이에서 Telnet으로 서버에 접속하는 사람들의 비밀번호가 대량으로 유출되는 사건들이 있었다. 보안 연구자들이 실험 삼아 공용 와이파이에서 패킷을 캡처했더니, 몇 시간 만에 수백 개의 계정 정보를 얻을 수 있었다는 보고도 있었다고한다.  

### SSH의 등장

1995년, 핀란드 헬싱키 공과대학의 교수가 자신의 대학 네트워크가 패스워드 스니핑 공격을 당하자, 이에 대응하기 위해 SSH-1을 개발했다. 이후 OpenBSD 팀이 이를 개선하여 1999년에 OpenSSH를 출시했고, 이게 지금까지 사실상의 표준이 되었다.

SSH의 핵심 아이디어는 간단하다.  **패킷이 중간에 캡처되는 건 막을 수 없으니, 내용을 암호화해서 읽을 수 없게 만들자**.

### SSH는 어떻게 작동하는가?

SSH와 Telnet은 둘 다 TCP 기반이다. TCP 관점에서 보면 둘 다 3-way handshake로 연결을 수립하고, 패킷을 순서대로 전송하고, 연결을 종료한다. 하지만 패킷을 암호화한다는 점에서 다르다.    
누군가 SSH 패킷을 캡처해도, 보이는 건 의미 없는 난수일 것이다.

### SSH 연결 과정의 3단계  
SSH 프로토콜을 활용하여 클라이언트가 서버에 접속하는 단계를 살펴보자.  

**1단계: 서버 신원 확인**  
서버가 자신의 호스트 키(공개키)를 클라이언트에게 보낸다. SSH로 처음 접속할 때 `The authenticity of host 'example.com' can't be established. RSA key fingerprint is SHA256:...`와 같은 메시지를 봤을 수도 있다. 이게  서버의 지문을 확인하는 과정이다. 'yes'를 입력하면 이 지문이 저장된다.

이후 접속할 때는 저장된 지문과 비교해서, 만약 다르다면 "중간자 공격 가능성"을 경고하고 연결을 차단한다. 이렇게 서버가 가짜가 아님을 확인한다.


**2단계: 암호화 방식 협상 및 세션 키 생성**  
서버와 클라이언트가 각자 지원하는 암호화 알고리즘 목록을 교환한다. 키 교환 알고리즘을 사용해 둘만 아는 비밀 세션 키를 만든다.
이 때 공개된 채널에서 정보를 교환하는데도, 중간에서 모든 걸 지켜본 공격자는 최종 세션 키를 알아낼 수 없게 된다(소수 관련 알고리즘 활용)..!


**3단계: 사용자 인증 및 암호화 통신**  
이제 생성된 세션 키로 모든 데이터를 대칭키 암호화로 암호화한다. 비밀번호를 입력하든, 공개키 인증을 하든, 이 모든 과정이 암호화된 터널 안에서 일어난다.  


