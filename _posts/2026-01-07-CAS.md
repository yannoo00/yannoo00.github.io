---
title:  "Compare and Exchange를 원자적으로 수행하기"
layout: post
excerpt: "network"

categories:
  - others 
tags:
  - [network]

toc: true
toc_sticky: true
 
date: 2026-01-10
last_modified_at: 2026-01-10
---

<br>

## Compare And Exchange  

멀티스레딩 환경에서,  
현재 내가 어떤 값을 건들여도 되는 상황인지 확인하고 "수정해도 ok"가 보장된 상태에서 값을 써야한다.  

이를 구현하는 방법으로 lock을 떠올릴 수 있다.  
lock 잡고,  
쓸 값이 현재 어떤 상태인지 체크하고,  
그 값을 수정한 후 
lock을 푼다.  
lock이 동시성을 보장해주긴 하지만 아무곳에서나 lock을 남발하면 서버 로직 실행에 방해요소가 된다.  
lock이 풀리기를 기다리는 만큼 자원이 낭비되고, dead lock의 위험이 생기는 등 ...  

멀티스레딩 환경에서 필수적으로 고민되어야 하는 부분이기 때문에, CPU 레벨에서 이를 atomic하게 수행할 수 있는  CAS가 있다.  
(Compare And Swap(CAS) = Compare And Exchange(CAE))  

CAS연산은 메모리 주소, 기대값, 새로 설정할 값까지 3가지 요소로 진행된다.  
메모리 주소에 있는 값이 기대값과 같다면, 메모리 주소의 값을 새로 설정할 값으로 덮어쓴다.  
이 과정이 CPU 명령어 하나로 수행되기 때문에 atomic이 보장된다.  

CPP에서는 compare_exchange_strong과 compare_exchange_weak 두 가지 함수를 사용할 수 있다.  
```cpp
// atomic_var.compare_exchange_strong(expected, desired);
bool success = atom.compare_exchange_strong(expected, desired);
```  
atom은 std::atomic<T>로 생성한 원자 연산을 지원하는 변수라고 보면 되고, 그 값이 CAS로 관찰하려는 값이 된다. 
이 값이 expected와 같으면 desired로 변경, 아니면 실패처리된다.  

weak, strong 두 가지 버전의 차이는 expected 값과 메모리의 값이 같을 때 '무조건 성공'하느냐, 아니면 같음에도 실패하느냐이다.  
왜 값이 같은데도 실패하는 것이고, 그걸 지원하는 함수가 왜 필요할까?  

이 때의 실패를 '가짜 실패'라고 한다.  
가짜 실패는 ARM 아키텍쳐에서 발생한다. 인텔은 문제 없이 CPU에서 지원하는 연산이지만 ARM에서는 사실 두 가지 연산(Load-Linked/Store-Conditional)으로 수행한다.  
읽기와 쓰기 연산 사이에 다른 스레드가 해당 메모리에 접근하면 Store-Conditonal이 실패할 수 있고 이것이 '가짜 실패'의 원인이 된다.  
weak의 경우 이 가짜 실패를 그대로 반환하고, strong은 가짜 실패 발생 시 내부에서 재시도하여 진짜 성공/실패(메모리의 값과 기대값이 같았는지)만 반환한다.  







